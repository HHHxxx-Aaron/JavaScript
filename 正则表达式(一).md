

# 正则表达式

> regular expression : RegExp

## 什么是正则表达式

> 正则表达式用来处理字符串规则
>
> - 只能处理字符串
> - 是一个规则：可以验证字符串是否符合某个规则（test），也可以把字符串中符合规则的部分捕获到（exec / match ...）

```javascript
let str = 'good good study, day day up!';
// 正则就是用来制定规则
let reg = /\d+/; // \d 代表0~9中的一个数字，+代表让其出现多次：是否包含数字
reg.test(str); // => false

str = "2020-11-18";
reg.exec(str); // => 把当前字符串中符合reg的捕获到：["2020", index: 0, input: "2020-11-18"]
```

## 编写正则表达式

### 创建方式

#### 1、字面量方式

```javascript
// 两个斜杠子件包起来的，都是用来描述规则的元字符
let reg = /\d+/;
```

#### 2、基于构造函数模式

```javascript
// 两个参数：元字符字符串， 修饰符字符串
let reg = new RegExp('\\d+'); // 需要加一个转义字符才能达到想要的效果
```



### 组成

- 元字符
- 修饰符

#### 常用元字符

> 量词元字符：设置出现的次数


| 序号 | 字符  | 含义                          |
| ---- | ----- | ----------------------------- |
| 1    | *     | 0到多次(可以出现，可以不出现) |
| 2    | +     | 1到多次                       |
| 3    | ?     | 0次或1次                      |
| 4    | {n}   | 出现n次                       |
| 5    | {n,}  | 出现n到多次                   |
| 6    | {n,m} | 出现n到m次(>=n,<=m)           |

> 特殊元字符：单个或者组合在一起代表特殊的含义

| 序号 | 字符 | 含义 |
| ---- | ---- | ---- |
| 1 | \ | 转义字符：普通->特殊->普通(来回相互转义) |
| 2 | . | 除 \n（换行符） 以外的任意字符 |
| 3 | ^ | 以哪一个元字符作为开始 |
| 4 | $ | 以哪一个元字符作为结束 |
| 5 | \n | 换行符 |
| 6 | \d | 0~9之间的一个数字 |
| 7 | \D | 非0~9之间的一个数字（大写和小写意思是相反的） |
| 8 | \w | 数字、字母、下划线中的任意一个字符 |
| 9 | \s | 一个空白字符（空格、制表符、换页符等） |
| 10 | \t | 一个制表符（一个tab键：四个空格） |
| 11 | x\|y | x或者y中的一个字符 |
| 12 | [xyz] | x或者y或者z中的一个字符 |
| 13 | [^xy] | 除了x或者y以外的任意字符 |
| 14 | [a-z] | 指定a-z这个范围中的任意字符 |
| 15 | [^a-z] | 上一行中的取反（非） |
| 16 | () | 正则中的分组符号 |
| 17 | (?:) | 只匹配，不捕获 |
| 18 | (?=) | 正向预查 |
| 19 | (?!) | 负向预查 |

> 普通元字符：代表本身含义的

```javascript
/abcd/ 此正则匹配的就是 “abcd”
```



> 正则表达式常用修饰符

```javascript
i => ignoreCase 忽略单词大小写匹配
m => multiline  可以进行多行匹配
g => global		全局匹配

// 例===
/A/.test('aabbcc'); 	// => false
/A/i.test('aabbcc'); 	// => true
```



##### 元字符详细解析

###### 1、^ $

```javascript
let reg = /^\d/; 		// 以数字开始
reg.test('aaa'); 		// => false
reg.test('2020aaa'); 	// => true
reg.test('aaa2020'); 	// => false
```

```javascript
let reg = /\d$/; 		// 以数字结束
reg.test('aaa'); 		// => false
reg.test('2020aaa'); 	// => false
reg.test('aaa2020'); 	// => true
```

```javascript
// => ^ $ 两个都不加：字符串中包含符合规则的内容即可
let reg1 = /\d/;			// 包含数字
// => ^ $ 两个都加：字符串只能是和规则一致的内容
let reg2 = /^\d+$/;
// 例：验证手机号码(11位，第一个数字是1即可)
let reg = /^1\d{10}$/;
```

```javascript
let reg = /^2.3$/;		// .不是小数点，是除\n以外的任意字符
reg.test('2.3'); 		// => true
reg.test('2@3'); 		// => true
reg.test('23'); 		// => false

reg = /^2\.3$/;			// 基于转义字符，让其只能代表小数点
reg.test('2.3'); 		// => true
reg.test('2@3'); 		// => false
reg.test('23'); 		// => false

let str = '\\d';		// 匹配这样一个字符串，这样写代表一个字符串"\d"
reg = /^\d$/;			// \d 代表0-9的数字
reg.test(str);			// => false
reg = /^\\d$/;			// 转义字符把特殊符号转换为普通的字符
reg.test(str);			// => true
```



###### 2、x|y

```javascript
let reg = /^18|29$/;
reg.test('18');		// => true
reg.test('29');		// => true
reg.test('129');	// => true
reg.test('189');	// => true
reg.test('1829');	// => true
reg.test('829');	// => true
reg.test('182');	// => true

// 直接x|y会存在很乱的优先级问题，一般写的时候都伴随着小括号进行分组，因为小括号改变处理的优先级
// 小括号 => 分组
reg = /^(18|29)$/; // 只能是 18 或者 29 中的一个
reg.test('18');		// => true
reg.test('29');		// => true
reg.test('129');	// => false
reg.test('189');	// => false
reg.test('1829');	// => false
reg.test('829');	// => false
reg.test('182');	// => false
```

###### 3、[]

> 1、中括号中间出现的字符一般都代表本身的含义
>
> 2、中括号中不存在多位数

```javascript
// 1、中括号中间出现的字符一般都代表本身的含义
let reg = /^[@+]+$/; // @或+中的任意一个出现1到多次
reg.test('@@');		// => true
reg.test('@+');		// => true

reg = /^[@+]$/;// @或+中的任意一个出现1次(只有1位)
reg.test('@');		// => true
reg.test('+');		// => true
reg.test('@@');		// => false
reg.test('@+');		// => false

reg = /^[\d]$/;		// \d在中括号中还是0-9的数字
reg.test('d');		// => false
reg.test('\\');		// => false
reg.test('1');		// => true

reg = /^[\\d]$/;	// \d在中括号中还是0-9的数字
reg.test('d');		// => true
reg.test('\\');		// => true
reg.test('1');		// => false

// 2、中括号中不存在多位数
reg = /^[18]$/;		// 1 或 8，不是18
reg.test('1');		// => true
reg.test('8');		// => true
reg.test('18');		// => false

reg = /^[10-29]$/;		// 1 || 0到2 || 9
reg.test('1');		// => true
reg.test('9');		// => true
reg.test('0');		// => true
reg.test('2');		// => true
reg.test('10');		// => false

reg = /^[(10-29)]$/;		// ( || 1 || 0到2 || 9 || )
reg.test('(');		// => true
reg.test(')');		// => true

reg = /^[\(10-29\)]$/;		// ( || 1 || 0到2 || 9 || )
// \( => (
```



### 常用正则表达式

#### 1、验证是否为有效数字

```javascript
/**
 * 规则分析：
 * 1、可能出现 + - 号，也可能不出现。只能出现一位 => [+-]?
 * 2、只有一位，0-9都可以，多位时首位不能为0 => (\d|[1-9]\d+)
 * 3、小数部分可能有可能没有，如果有，后面必须有小数点加数字 => (\.\d+)?
 */
let reg = /^(+|-)?(\d|[1-9]\d+)(\.\d+)?$/;
let reg = /^[+-]?(\d|[1-9]\d+)(\.\d+)?$/;
```

#### 2、验证密码

```javascript
// 数字、字母、下划线
// 6-16位
let reg = /^\w{6,16}$/;
```

#### 3、验证真实姓名

```javascript
/**
 * 规则分析：
 * 1、汉字 => /^[\u4E00-\u9FA5]$/
 * 2、名字长度 2~10位 => {2,10}
 * 3、可能有译名(可能出现多次)：·汉字 => (·[\u4E00-\u9FA5]{2,10})*
 */
// 例：奥克多·维克奇·林奥·拉布拉多
let reg = /^[\u4E00-\u9FA5]{2,10}(·[\u4E00-\u9FA5]{2,10})*$/;
```

#### 4、验证邮箱

```javascript
let reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+/;
// => \w+((-\w+)|(\.\w+))*
// 1、开头是数字字母下划线（1到多位）
// 2、还可以是 “-数字字母下划线” 或者 “.数字字母下划线”，整体0到多次
// 3、邮箱的名字由“数字、字母、下划线、'-'、'.'”几部分组成，但是-/.不能连续出现也不能作为开始

// => @[A-Za-z0-9]+
// 1、@后面紧跟着：数字、字母（1到多位）

// => ((\.|-)[A-Za-z0-9]+)*
// 1、对@后面名字的补充
// 多域名
// 企业邮箱

// => \.[A-Za-z0-9]+
// 1、这个匹配的是最后的域名(.com/.cn/.org/.edu./.net/.vip等等)
```

#### 5、身份证号码

```javascript
/**
 * 规则分析：
 * 1、一共18位
 * 2、最后一位可能是 X
 */
let reg = /^\d{17}(\d|X)$/;
// 身份证前6位：省市县
// 中间8位：年月日
// 最后四位：
// 	+ 最后一位：X或者数字
// 	+ 倒数第二位：偶数女，奇数男
// 	+ 其余的是经过算法算出来的
// => 小括号分组的第二个作用：分组捕获，不仅可以把大正则匹配的信息捕获到，还可以单独捕获到每个小分组的内容
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/;
reg.exec(身份证号码); // 捕获结果是数组，包含每一个小分组单独获取的内容
// 可以使用下面这种校验
reg = /^[1-9][0-9]{5}(18|19|(2[0-9]))[0-9]{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)[0-9]{3}[0-9Xx]$/;
```



### 两种创建方式的区别

```javascript
// => 构造函数因为传递的是字符串， "\" 需要 "\\" 才代表 "\"
let reg = /\d+/g;
reg = new RegExp("\\d+", "g");

// => 正则表达式中的部分内容是变量存储的值
// 1、两个斜线中间包起来的都是元字符(如果正则中要包含某个变量的值，则不能使用字面量方式创建)
let type = 'aaron';
reg = /^@"+type+"@$/;
reg.test('@aaron@'); 		// => false
reg.test('@"aaron"@'); 		// => false
reg.test('@"type"@'); 		// => true
reg.test('@""typeee"@'); 	// => true

// 2、这种情况只能使用构造函数方式，因为他传递的规则是字符串，只有这样才能进行字符串拼接
let type = 'aaron';
let reg = new RegExp("^@"+type+"@$");
reg.test('@"aaron"@'); 	// => false
reg.test('@aaron@');	// => true
```

##  正则的捕获

### 实现正则捕获的方法

#### 1、正则RegExp.prototype上的方法

##### 1）exec

##### 2）test



#### 2、字符串String.prototype上支持正则表达式的方法

##### 1）replace

##### 2）match

##### 3）splite

```javascript
let str = 'ab12cd34ef56';
let reg = /^\d+$/;
// => 实现正则捕获的前提是：当前正则要和字符串匹配，如果不匹配捕获的结果是null
reg.test(str); // => false
reg.exec(str); // => null

/**
 * 基于 exec 实现正则的捕获
 * 1、捕获到的结果是 null 或者一个数组
 *    数组第一项：本次捕获到的内容
 *	  其余项：对应小分组本次单独捕获的内容
 *    index：当前捕获内容在字符串中的起始索引
 *    input：原始字符串
 * 2、每执行一次exec只能捕获到一个捕获正则规则的，但是默认情况下，执行多次，获取的结果永远都是第一个匹配到的，其余的捕获不到
 *    => 正则捕获的懒惰性：默认只捕获第一个
 
 */
reg = /\d+/;
reg.test(str); // => true
reg.exec(str); // => ["12", index: 2, input: "ab12cd34ef56", groups: undefined]

// reg.lastIndex => lastIndex：当前正则下一次匹配的起始索引位置（懒惰性捕获的原因：默认情况下lastIndex的值不会被修改，每一次都是从字符串开始位置查找，所以找到的永远只是第一个）
```

















